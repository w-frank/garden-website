<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Will Frank</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Will Frank">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <link href="/static/css/colorbox.css" rel="stylesheet">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
        <link href="/static/css/style.css" rel="stylesheet">

        <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Space Mono">
        <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Poppins" >
        
    </head>
    <body>
        <div class="container">
            <nav class="navbar navbar-default" role="navigation">
                    <div class="navbar-header">
                        <h1 class="navbar-brand" href="https://willfrank.co.uk">Will Frank</h1>
                    </div>
                    <!--<div class="collapse navbar-collapse">-->
                    <ul class="nav navbar-nav">
                                <li><a href="/">Home</a></li>
                                <li><a href="/pages/portfolio.html">Portfolio</a></li>
                                <li><a href="/pages/about.html">About</a></li>
                    </ul>
                    <!--</div>-->
            </nav>
<div class="row">
    <div class="col-md-8">
        <h1><a href="/stm32-vcp.html">STM32: USB Virtual COM Port (VCP)</a></h1>
        <label class="tag" href="/tags/STM32.html">STM32</label>
        <label class="tag" href="/tags/ARM.html">ARM</label>
        <label class="tag" href="/tags/linux.html">linux</label>
        <label class="tag" href="/tags/programming.html">programming</label>
        </label>
        <label class="font-weight-normal text-muted">&#8226 13 February, 2022</label>
        <p><p>Serial communication is really useful for interfacing microcontrollers with
external devices (GPS, WiFi, Bluetooth modules) or to a host PC for debugging or
data transfer. For STM32 devices a USB-UART bridge can be used to communicate
with a USB device such as a PC. However, many of the STM32 development boards
have a USB peripheral on-board. This tutorial covers setting up the STM32F4
Discovery board as a virtual COM port (VCP) to enable USB communication to and
from a PC.</p>
<p>I'm using the STM32 Discovery board which has an STM32F407VG microcontroller and
an on-board micro USB port. I'm using the STM32 Cube Framework with the HAL
libraries and USB device middleware for this application. I'm developing on a PC
running Ubuntu 20.04.3.</p>
<p>First, open STM32CubeIDE and start a new STM32 project
<strong>File &gt; New &gt; STM32 Project</strong>. Select your microcontroller or development board.
Here I select the STM32F4 Discovery (STM32F407G-DISC1).</p>
<p><img alt="img-full-width" src="./images/stm32-vcp/board-select.png"></p>
<p>Click <strong>Next &gt;</strong>, name your project (e.g. "usb_vsp_test") and leave the rest as
default. We'll be using C as our programming language in this example. Click
<strong>Finish</strong>, and you'll be prompted for a couple of settings:</p>
<ul>
<li><strong>Yes</strong>, to "Initialize all peripherals with their default Mode?"</li>
<li><strong>Yes</strong>, to "Open this perspective now"</li>
</ul>
<p>Now in the STM32 CubeMX configuration perspective, Under the <strong>Pinout &amp;
Configration</strong> tab in the <strong>System Core</strong> section, select <strong>RCC</strong>. Then, under
<strong>RCC Mode and Configuration</strong>, enable the High Speed External (HSE) clock and
select Ceramic/Crystal Resonator. Note: this may already be configured by
default.</p>
<p><img alt="img-full-width" src="./images/stm32-vcp/rcc.png"></p>
<p>In the <strong>Connectivity</strong> section select <strong>USB_OTG_FS</strong> and confuigure the mode as
<strong>Device_Only</strong>. You can also disable <strong>Activate_VBUS</strong>. On the STM32F4
Discovery pins PA11 and PA12 are configured for OTG_FS_DM and OTG_FS_DP.</p>
<p><img alt="img-full-width" src="./images/stm32-vcp/usb-otg-fs.png"></p>
<p>Finally, under the <strong>Middleware</strong> section, select the <strong>USB_DEVICE</strong> and set the
<strong>Class For FS IP</strong> as <strong>Communication Device Class (Virtual Port Com)</strong>. Leave
the <strong>Configuration &gt; Parameter Settings</strong> as default.</p>
<p><img alt="img-full-width" src="./images/stm32-vcp/usb-device.png"></p>
<p>Next, save the CubeMX (.ioc) file to generate the code. Click <strong>File &gt; Save</strong> to
save the changes to the CubeMX configuration. You’ll be asked if you want to
generate code. Click <strong>Yes</strong>.</p>
<p>Now all the peripherals are enabled for the USB communication over VCP. But as
the HAL USB stack is heavy on the memory, the minimum heap size needed has to be
changed. This can be changed by opening the <strong>Project Manager</strong> tab and changing
the <strong>Minimum Heap Size</strong> to <code>0x600</code> under <strong>Linker Settings</strong>.</p>
<p><img alt="img-full-width" src="./images/stm32-vcp/heap-size.png"></p>
<p>Click <strong>File &gt; Save</strong> to save the changes to the CubeMX configuration. You’ll be
asked again if you want to generate code. Click <strong>Yes</strong>.</p>
<h2>Serial Echo</h2>
<p>Lets test this setup with a simple echo application using the USB CDC. First
open the <code>USB_DEVICE &gt; App &gt; usbd_cdc_if.c</code> file. Find the
<code>CDC_Receive_FS</code> function and edit:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="nf">CDC_Receive_FS</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">Buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">Len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* USER CODE BEGIN 6 */</span><span class="w"></span>
<span class="w">    </span><span class="n">USBD_CDC_SetRxBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hUsbDeviceFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">USBD_CDC_ReceivePacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hUsbDeviceFS</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">CDC_Transmit_FS</span><span class="p">(</span><span class="n">Buf</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Len</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">USBD_OK</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* USER CODE END 6 */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Note that <code>CDC_Receive_FS</code> is a static function so cannot be called outside
of <code>usbd_cdc_if.c</code>. This code takes characters from the recieve buffer and
sends them straight back out again using the CDC transmit function.</p>
<p>Now build the project and download the program to the board using the built in
ST-Link. Click <strong>Project &gt; Build All</strong> to build the project. Click
<strong>Run &gt; Debug As &gt; STM32 MCU C/C++ Application</strong>. A pop-up window will appear
asking you to create a new launch configuration. Note that if you are not using
a Nucleo/Discovery board or an ST-LINK, you can change the hardware debugger
(e.g. to a Segger J-LINK) in the Debugger tab. If you are using a
Nucleo/Discovery, leave everything as default and click <strong>OK</strong>.</p>
<p>When connected to your host PC by the micro USB (next to the audio jack on the 
STM32F4 Discovery board), the serial port should show up as <code>/dev/ttyACM1</code>
on most Linux distributions. Start up your favourite serial port terminal, such
as gtkterm and open <code>ttyACM1</code>. The baud rate doesn't matter as it's ignored
by the progam. On Ubuntu:</p>
<div class="highlight"><pre><span></span><code>sudo apt-get install gtkterm
sudo gtkterm
</code></pre></div>

<p>Set the following serial port settings:
the following connection details:</p>
<ul>
<li>Port: ttyACM1</li>
<li>Baud rate: 115200 (default)</li>
<li>Data bits: 8 (default)</li>
<li>Parity: None (default)</li>
<li>Stop bits: 1 (default)</li>
</ul>
<p>Type a message in the serial monitor and press send. The STM32 device will
echo back the message you typed!</p>
<h2>Controlling a built-in LED using the VCP</h2>
<p>The Virtual COM Port (VCP) opens up the possibility of remote control of the
STM32. As a simple example, the built-in LED on the STM32F4 Discovery can be
turned on and off using the VCP.</p>
<p>First, open the CubeMX (.ioc ) file again to generate the code for the LED. In
the CubeMX perspective, select the pin for the LED (which is PD13 for the orange
LED on the STMF4 Discovery board) and set as <strong>GPIO_Output</strong>. Note, if you setup
all peripherals with their default mode, this will already be done. Now save the
file to generate the code again. Next change the <code>CDC_Receive_FS</code> function
in <code>USB_DEVICE &gt; App &gt; usbd_cdc_if.c</code> as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="nf">CDC_Receive_FS</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">Buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">Len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* USER CODE BEGIN 6 */</span><span class="w"></span>
<span class="w">    </span><span class="n">USBD_CDC_SetRxBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hUsbDeviceFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">USBD_CDC_ReceivePacket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hUsbDeviceFS</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOD</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_PIN_13</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_PIN_SET</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOD</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_PIN_13</span><span class="p">,</span><span class="w"> </span><span class="n">GPIO_PIN_RESET</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">USBD_OK</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* USER CODE END 6 */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Here we check the USB receive buffer to see if we got either <code>0</code> or <code>1</code>.
If we get <code>1</code> we turn the LED on with <code>HAL_GPIO_WritePin()</code>. If we get
<code>0</code> we turn the LED off.</p>
<h2>Hello World!</h2>
<p>Start with a new USB VCP project following the steps above. Open up <code>Src &gt;
main.c</code>. At the top, under <code>/* USER CODE BEGIN Includes */</code> , include the 
USB CDC library header:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;usbd_cdc_if.h&quot;</span><span class="cp"></span>
</code></pre></div>

<p>This will let us call functions from the USB CDC library in our main program.
Scroll down to our <code>while(1)</code> loop in main. Under
<code>/* USER CODE BEGIN 3 */</code> (but still inside the while loop), enter the
following:</p>
<div class="highlight"><pre><span></span><code><span class="kt">uint8_t</span><span class="w"> </span><span class="n">msg_buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello world!</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">CDC_Transmit_FS</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">));</span><span class="w"></span>
<span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<p>Here we create a simple message string and use the USB CDC transmit function to
send the string over USB. We then wait for 1 second before repeating this action
for ever!</p>
<p>Build and run the project as before. Open the serial connection, and you should
be greeted by that oh-so-familiar phrase, repeating over and over again:</p>
<p><img alt="img-full-width" src="./images/stm32-vcp/hello-world.png"></p></p>
        <h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'willfrank-co-uk'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    <div class="col-md-3">
        <h4>Recent Posts</h4>
        <ul id="recent-posts">
            <li><a href="/stm32-vcp.html">STM32: USB Virtual COM Port (VCP)</a></li>
            <li><a href="/stm32-led.html">STM32: Blink an LED</a></li>
            <li><a href="/sending-files-with-kermit-1.html">Sending Files Over Serial With Kermit</a></li>
            <li><a href="/port-audio-1.html">Build and Use PortAudio on Linux (using CMake)</a></li>
        </ul>
        <!--
        <h4>Categories</h4>
        <ul id="category-list">
            <li><a href="/category/linux.html">Linux</a></li>
            <li><a href="/category/stm32.html">STM32</a></li>
        </ul>
        -->
        <h4>Tags</h4>
        <ul id="tag-list">
            <li><a href="/tag/stm32.html">STM32</a></li>
            <li><a href="/tag/arm.html">ARM</a></li>
            <li><a href="/tag/linux.html">linux</a></li>
            <li><a href="/tag/programming.html">programming</a></li>
            <li><a href="/tag/audio.html">audio</a></li>
        </ul>
    </div>
</div>
        </div>
        <footer class="blog-footer">
            <div class="container">
                <span class="text-muted">Will Frank 2022. Handcrafted using <a href="https://www.python.org/">Python</a>, <a href="https://docs.getpelican.com/en/stable/">Pelican</a> and <a href="https://getbootstrap.com/">Bootstrap</a>. Published with <a href="https://pages.github.com/">GitHub Pages.</a></span>
            </container>
        </footer>

        <script src="/static/js/jquery.min.js"></script>
        <!-- Make sure jquery is loaded first, then load colorbox -->
        <script src="/static/js/jquery.colorbox-min.js"></script>
        <script src="/static/js/load-colorbox.js"></script>
        <script type="text/javascript">
            $(document).ready(function () {
                var url = window.location;
                $('.navbar-nav a[href="'+ url +'test"]').parent().addClass('active');
                $('.navbar-nav a').filter(function() {
                     return this.href == url;
                }).parent().addClass('active');
            });
        </script> 
    </body>
</html>